package com.github.audio.util.gen;

import com.github.audio.Audio;
import com.github.audio.registryHandler.AudioRegistryHandler;
import com.github.audio.sound.AudioSound;
import com.github.audio.util.IAudioTool;
import com.github.audio.util.Utils;
import org.jaudiotagger.audio.exceptions.CannotReadException;
import org.jaudiotagger.audio.generic.GenericAudioHeader;
import org.jaudiotagger.audio.ogg.util.OggInfoReader;

import java.io.*;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.*;
import java.util.jar.JarEntry;
import java.util.jar.JarFile;
import java.util.jar.JarOutputStream;
import java.util.stream.Collectors;
import java.util.zip.ZipEntry;

public class IOHelper implements IAudioTool {

    /**
     * @Description: The path to the .zip or .jar for resource folder which is mainly for store
     * the sound resource, at the very first of time this might be designed for .jar but later
     * this is probably for .zip's visit.
     */
    private final String jarPath;
    /**
     * @Description: The zip or jar for visit while doing operation to the file, usually for
     * input resource from custom resource which is from client side.
     */
    private final JarFile zip;
    /**
     * @Description: This is the folder for player to store the origin music file which is probably
     * be translated into the type of .ogg, in the audio sound generate cycle the .ogg music in this
     * file will be all put into the resource path, into the given zip.
     */
    private final File music;

    private static final IOHelper IO_HELPER = new IOHelper(Utils.RESOURCE_ZIP_PATH);
    private static final AudioSound.NameGenerator gen = new AudioSound.NameGenerator();

    public static IOHelper getInstance() {
        return IO_HELPER;
    }

    private IOHelper(String jarPath) {
        JarFile temZip;
        this.jarPath = jarPath;
        this.music = new File(Utils.MUSIC_FOLDER_PATH);
        try {
            temZip = new JarFile(jarPath);
        } catch (IOException e) {
            Audio.warn("The given jar path could not be found, this is probably caused by the resource folder named \" audioresource.zip \"" +
                    " is not placed in the right place, plz check if you have download this resource pack and have it loaded on your minecraft.");
            temZip = null;
        }
        this.zip = temZip;
    }

    public static Optional<Long> getOggDuration(File file) throws IOException, CannotReadException {
        RandomAccessFile randomAccessFile = new RandomAccessFile(file, "rwd");
        OggInfoReader oggInfoReader = new OggInfoReader();
        GenericAudioHeader read = oggInfoReader.read(randomAccessFile);
        return Optional.of(toTicks(read.getPreciseTrackLength()));
    }

    @Deprecated
    private static Optional<Long> getOggDuration(String registryName) throws IOException, CannotReadException {
        File file = new File("src\\main\\resources\\assets\\audio\\sounds\\" + registryName + ".ogg");
        return getOggDuration(file);
    }

    private static <T extends Number> long toTicks(T second) {
        return Math.round(second.doubleValue() * 20);
    }

    public void generateMusicFolder() throws CannotReadException, IOException {
        if (!music.exists()) {
            Audio.info(music.mkdir() ? "Music Folder is created at " + Utils.MUSIC_FOLDER_PATH
                    : "Try create music folder but fail.");
        } else for (File file : Objects.requireNonNull(music.listFiles()))
            AudioRegistryHandler.CUSTOM_FILE_MAP.put(file.getName().split(".ogg")[0],
                    getOggDuration(file).orElse(-1L));
        //Debug
//        AudioRegistryHandler.CUSTOM_FILE_MAP.forEach((key, val) -> Audio.info("from DURATION :" + key + " : " + val));
    }

    public int countFile() {
        if (!music.exists()) return -1;
        return Objects.requireNonNull(music.listFiles()).length;
    }

    @Deprecated
    public int countJar() throws IOException {
        return getZipFileNames().size();
    }

    /**
     * @return an Array of String that contains the filename in the jar , also called 'entry'
     * @clclfl: May better use method : getZipFileNames()
     */
    @SuppressWarnings("resource")
    @Deprecated
    public String[] getEntries() throws IOException {
        ArrayList<String> fileList = new ArrayList<>();
        Enumeration<JarEntry> entries = zip.entries();
        while (entries.hasMoreElements()) {
            fileList.add((entries.nextElement()).getName());
        }
        return fileList.toArray(new String[0]);
    }

    @SuppressWarnings("resource")
    public List<String> getZipFileNames() {
        return zip.stream().map(ZipEntry::getName).collect(Collectors.toList());
    }

    /**
     * @param entryName Which provided to locate the file or folder in jar.But remember,
     *                  if you want to extract a folder,please add a '/' behind or something
     *                  unexpected might happen.
     */
//    public void extractEntry(String entryName, String filePath) throws IOException {
//        TreeMap<String, byte[]> entryMap = new TreeMap<>();
//        Enumeration<JarEntry> iterator = zip.entries();
//        String signedName = processEntryName(entryName);
//        while (iterator.hasMoreElements()) {
//            JarEntry jarEntry = iterator.nextElement();
//            if (jarEntry.getName().startsWith(entryName)) { //Sub or not
//                if (jarEntry.isDirectory())
//                    new File(signedName + jarEntry.getName().substring(entryName.length())).mkdir();
//                else
//                    entryMap.put(signedName + jarEntry.getName().substring(entryName.length()), readZip(new JarEntry(jarPath)));
//            }
//        }
//        for (String externFileName : entryMap.keySet())
//            new FileOutputStream(externFileName).write(entryMap.get(externFileName)); //We still need to judge here
//    }

    public void deleteEntry(String entryName) throws IOException {
        TreeMap<String, byte[]> entryMap = readZip();
        Set<String> collect = entryMap.keySet().stream().filter(k -> k.startsWith(entryName)).collect(Collectors.toSet());
        for (String key : collect) {
            entryMap.remove(key);
        }
        writeZip(entryMap, new JarOutputStream(Files.newOutputStream(Paths.get(jarPath))));
        Audio.info("Entry deleted.");
    }

    /**
     * @param file      the file you want to insert into a jar or zip
     * @param path Which provided to locate where you want to insert your file to.And notice
     *                  that it's path but not file name.
     */
    public void fileInsert(File file, String path) throws IOException {
        if (!file.exists() && file.isDirectory()) {
            Audio.warn("File not found or you just input a folder!");
            return;
        }

        TreeMap<String, byte[]> entryMap = readZip();
        rewriteMap(entryMap, path + file.getName(), readFile(file));
        writeZip(entryMap, new JarOutputStream(new FileOutputStream(jarPath)));
    }

    /**
     * @param folder     the folder you want to insert into a jar or zip
     * @param entryPath  Which provided to locate where you want to insert your file to.And notice
     *                   that it's path but not file name.
     * @param keepParent To make sure if you want to keep the parent folder or not.For example,if you
     *                   want to insert whole "sounds/" into "assets/audio/",then true would make it
     *                   "assets/audio/sounds".oppositely false would make it "assets/audio/xxx.ogg(files in folder)"
     */
    public void folderInsert(File folder, String entryPath, boolean keepParent) throws IOException {
        if (folder.exists() && folder.isDirectory()) {
            Audio.info("Start inserting folder");
            TreeMap<String, byte[]> entryMap = readZip();
            TreeMap<String, byte[]> folderMap = readFolder(folder);
            folderMap.forEach((fileName, fileContent) -> {
                boolean reWrite = keepParent ?
                        rewriteMap(entryMap, entryPath + folder.getName() + '/' + fileName, fileContent) :
                        rewriteMap(entryMap, entryPath + fileName, fileContent);

            });
            writeZip(entryMap, new JarOutputStream(new FileOutputStream(jarPath)));
            Audio.info("Done insertion");
        } else
            Audio.warn("Folder not found or you just input a file!");
    }

    public void simpleInsert(File file, String entryPath, boolean keepParent) throws IOException {
        if (!file.exists() && !file.isDirectory()) return;
        TreeMap<String, byte[]> destination = readZip(); //resource
        TreeMap<String, byte[]> resources = readFolder(file); //music
        resources.forEach((fileName, fileContent) -> {
                    if (keepParent)
                        rewriteMap(destination, entryPath + file.getName() + '/' + gen.get() + ".ogg", fileContent);
                    else
                        rewriteMap(destination, entryPath + gen.get() + ".ogg", fileContent);
                }
        );
        writeZip(destination, new JarOutputStream(new FileOutputStream(jarPath)));
    }

    //    private byte[] readIntoByte(InputStream stream) throws IOException {
//        ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
//        byte[] buffer = new byte[2048];
//        int len;
//        while ((len = stream.read(buffer)) != -1) outputStream.write(buffer, 0, len);
//        stream.close();
//        outputStream.close();
//        return outputStream.toByteArray();
//    }
//
//
//    private byte[] readZip(JarFile modJar, JarEntry jarEntry) throws IOException {
//        return readIntoByte(modJar.getInputStream(jarEntry));
//    }
//
//    private byte[] readFile(File file) throws IOException {
//        return readIntoByte(Files.newInputStream(file.toPath()));
//    }

    private BufferedOutputStream readZip(JarEntry zipEntry) throws IOException {
        BufferedInputStream bis = new BufferedInputStream(zip.getInputStream(zipEntry));
        BufferedOutputStream bos = new BufferedOutputStream(new ByteArrayOutputStream());
        byte[] bytes = new byte[2048];
        int len = 0;
        while ((len = bis.read(bytes)) != -1) {
            bos.write(bytes, 0, len);
        }
        bis.close();
        return bos;
    }

    private BufferedOutputStream readFile() throws IOException {
        BufferedInputStream bis = new BufferedInputStream(Files.newInputStream(music.toPath()));
        BufferedOutputStream bos = new BufferedOutputStream(new ByteArrayOutputStream());
        byte[] bytes = new byte[2048];
        int len = 0;
        while ((len = bis.read(bytes)) != -1) {
            bos.write(bytes, 0, len);
        }
        bis.close();
        return bos;
    }


    private TreeMap<String, byte[]> readFolder(File folder) throws IOException {
        TreeMap<String, byte[]> fileInfo = new TreeMap<>();
        for (File file : Objects.requireNonNull(folder.listFiles())) fileInfo.put(file.getName(), readFile(file));
        TreeMap<String, String> map = new TreeMap<>(new Comparator<String>() {
            @Override
            public int compare(String o1, String o2) {
                return o1.toLowerCase().charAt(0) - o2.toLowerCase().charAt(0);
            }
        });
        return fileInfo;
    }

    private void writeZip(TreeMap<String, byte[]> entryMap, JarOutputStream outputStream) throws IOException {
        for (Map.Entry<String, byte[]> entry : entryMap.entrySet()) {
            outputStream.putNextEntry(new JarEntry(entry.getKey()));
            outputStream.write(entry.getValue(), 0, entry.getValue().length);
        }
        outputStream.close();
    }

//    private TreeMap<String, byte[]> readZip() {
//        TreeMap<String, byte[]> jarInfo = new TreeMap<>();
//        zip.stream().forEach(e -> {
//            try {
//                jarInfo.put(e.getName(), readZip(zip, e));
//            } catch (IOException ex) {
//                ex.printStackTrace();
//            }
//        });
//        return jarInfo;
//    }

    private TreeMap<String, byte[]> readZip() throws IOException {
        TreeMap<String, byte[]> entryMap = new TreeMap<>();
        Enumeration<JarEntry> entries = zip.entries();
        while (entries.hasMoreElements()) {
            JarEntry entry = entries.nextElement();
            entryMap.put(entry.getName(), readZip(zip, entry));
        }
        return entryMap;
    }

    private boolean rewriteMap(TreeMap<String, byte[]> entryMap, String key, byte[] value) {
        entryMap.remove(key);
        entryMap.put(key, value);
        return true;
    }

    private String processEntryName(String entryName) {
        String[] entryPiece = entryName.split("/");
        entryName = entryName.endsWith("/") ?
                entryName.equals(entryPiece[entryPiece.length - 1] + '/') ?
                        entryName : entryPiece[entryPiece.length - 1] + '/'
                : entryName.equals(entryPiece[entryPiece.length - 1]) ?
                entryName : entryPiece[entryPiece.length - 1];
        return entryName;
    }
}
